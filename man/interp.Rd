% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/interp.R
\name{interp}
\alias{interp}
\title{\code{interp} - Interpolate}
\usage{
interp(new_age, cdf_array, age_array, cutoff = 450, method = 3)
}
\arguments{
\item{new_age}{integer - value of the new age whose CDF is to be interpolated}

\item{cdf_array}{numeric vector of CDFs (usually representative of the selected factors)}

\item{age_array}{numeric vector of ages corresponding to the supplied \code{cdf_array}}

\item{cutoff}{the largest possible age, after which, no interpolation is performed}

\item{method}{integer - must be 1, 2, or 3 where 1 represents linear, 2 represents exponential,
and 3 represents double exponential. Defaults to 3, but falls back onto 1 if necessary.

\section{Formulas}{
For Linear Interpolation the formula is as follows:
\if{html}{\figure{dblexp.svg}{options: width=100 alt="Double Exponential Interpolation"}}
\if{latex}{\figure{dblexp.svg}{options: width=0.5in}}
}}
}
\value{
derived numeric value for the supplied \code{new_age}'s CDF
}
\description{
Interpolate Cumulative Loss Development Factors
}
\details{
Actuaries often have to \code{interpolate} values in between the selected LDFs/CDFs
in order to derive development factors at a variety of possible ages of maturity.

This generic function comes with three possible \code{method}s:
\enumerate{
\item Linear Interpolation
\item Exponential Interpolation
\item Double Exponential Interpolation
}
}
\examples{
cdfs <- c(3.579, 2.866, 2.489, 2.121, 1.876, 1.543, 1.222, 1.150, 1.109, 1.005, 1.0025)
ages <- seq(from = 12, to = (length(cdfs) * 12), by = 12)

interp(14, cdfs, ages)
interp(12, cdfs, ages) == cdfs[[1]]
interp(27, cdfs, ages, method = 2)
}
